class t extends Array{constructor(t=1,e=0){super(),this.x=t,this.y=e}set x(t){this[0]=t}set y(t){this[1]=t}get x(){return this[0]}get y(){return this[1]}get length(){return Math.hypot(this.x,this.y)}get dir(){return Math.atan2(this.y,this.x)}copy(){return new t(this.x,this.y)}add(t){return this.x+=t.x,this.y+=t.y,this}sub(t){return this.x-=t.x,this.y-=t.y,this}scale(t){return this.x*=t,this.y*=t,this}rotate(t){const e=Math.cos(t),r=Math.sin(t),[i,n]=this;return this.x=i*e+n*-r,this.y=i*r+n*e,this}cross(t){return this.x*t.y-t.x*this.y}dot(t){return this.x*t.x+t.y*this.y}normalize(){return this.scale(1/this.length)}}function e(e,r){return new t(e.x+r.x,e.y+r.y)}function r(e,r){return new t(e.x-r.x,e.y-r.y)}class i{constructor(t){this.instructArray=[]}static install(t){this.mot=t,t.register("createPath",(t=>new i(t)))}parse(t){const e=t.trim().replace(/\s/g," ").split(" ").filter((t=>""!==t)),r=e.length,i=[];let n={};for(let t=0;t<=r;t+=2)"Z"!==e[t]?n[e[t]]=e[t+1]:(i.push(this.createInstruct(n)),n={});return i}createInstruct(t){const e={duration:t.T||400,timeFunction:t.E||"linear",instruct:"",value:""};for(const r in t)"T"!==r&&"E"!==r&&(e.instruct=r,e.value=t[r]);return e}quadraticBezierCurve(){}bezier2P(t,e,r,i){return t*Math.pow(1-i,2)+2*e*i*(1-i)+r*i*i}getBezierNowPoint2P(t,e,r,i,n){return{x:this.bezier2P(t.x,e.x,r.x,i*n),y:this.bezier2P(t.y,e.y,r.y,i*n)}}create2PBezier(t,e,r,i=100,n=1){const s=n/(i-1),o=[];for(let n=0;n<i;n++){const i=this.getBezierNowPoint2P(t,e,r,n,s);o.push({x:i.x,y:i.y})}return o}bezier3P(t,e,r,i,n){return t*Math.pow(1-n,3)+3*e*n*Math.pow(1-n,2)+3*r*Math.pow(n,2)*(1-n)+i*Math.pow(n,3)}getBezierNowPoint3P(t,e,r,i,n,s){return{x:this.bezier3P(t.x,e.x,r.x,i.x,n*s),y:this.bezier3P(t.y,e.y,r.y,i.y,n*s)}}create3PBezier(t,e,r,i,n=100,s=1){const o=n,h=s/(o-1),a=[];for(let n=0;n<o;n++){const s=this.getBezierNowPoint3P(t,e,r,i,n,h);a.push({x:s.x,y:s.y})}return a}createSmoothLine(e,r=.3){const i=e.length;let n=[];const s=[];if(!(i<3)){for(let o=0;o<i-2;o++){const{control1:h,control2:a}=this.createSmoothLineControlPoint(new t(e[o].x,e[o].y),new t(e[o+1].x,e[o+1].y),new t(e[o+2].x,e[o+2].y),r);let c,u;s.push(h),s.push(a),0===o?c=this.create2PBezier(e[o],h,e[o+1],50):(console.log(s),c=this.create3PBezier(e[o],s[2*o-1],h,e[o+1],50)),o+2===i-1&&(u=this.create2PBezier(e[o+1],a,e[o+2],50)),n=o+2===i-1?[...n,...c,...u]:[...n,...c]}return n}}createSmoothLineControlPoint(t,i,n,s=.3){const o=r(t,i),h=r(t,i),a=o.length/h.length;let c;c=a>1?r(t,e(i,r(n,i).scale(1/a))):r(e(i,r(t,i).scale(a)),n),c=c.scale(s);return{control1:{x:e(i,c).x,y:e(i,c).y},control2:{x:r(i,c).x,y:r(i,c).y}}}}i.pluginName="mot-plugin-path",i.installed=!1,window.motPluginPath&&console.warn("'motPluginPath' had been used,and it will be covered"),window.motPluginPath=i;export default i;
